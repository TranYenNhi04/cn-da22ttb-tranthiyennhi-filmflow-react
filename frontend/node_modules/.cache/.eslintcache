[{"D:\\cn\\phim\\frontend\\src\\index.js":"1","D:\\cn\\phim\\frontend\\src\\App.js":"2","D:\\cn\\phim\\frontend\\src\\pages\\HomePage.js":"3","D:\\cn\\phim\\frontend\\src\\pages\\RecommendationsPage.js":"4","D:\\cn\\phim\\frontend\\src\\config.js":"5","D:\\cn\\phim\\frontend\\src\\pages\\AuthPage.js":"6","D:\\cn\\phim\\frontend\\src\\pages\\ProfilePage.js":"7","D:\\cn\\phim\\frontend\\src\\pages\\CollectionsPage.js":"8","D:\\cn\\phim\\frontend\\src\\components\\MovieSkeleton.js":"9","D:\\cn\\phim\\frontend\\src\\components\\LazyImage.js":"10"},{"size":207,"mtime":1763988944338,"results":"11","hashOfConfig":"12"},{"size":5764,"mtime":1766577534193,"results":"13","hashOfConfig":"12"},{"size":28514,"mtime":1766673014516,"results":"14","hashOfConfig":"12"},{"size":51102,"mtime":1766582859573,"results":"15","hashOfConfig":"12"},{"size":105,"mtime":1764592653500,"results":"16","hashOfConfig":"12"},{"size":5382,"mtime":1765700942358,"results":"17","hashOfConfig":"12"},{"size":16936,"mtime":1766583136306,"results":"18","hashOfConfig":"12"},{"size":4975,"mtime":1766571499111,"results":"19","hashOfConfig":"12"},{"size":866,"mtime":1766415376954,"results":"20","hashOfConfig":"12"},{"size":1555,"mtime":1766665978349,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1qpzex9",{"filePath":"24","messages":"25","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"26"},{"filePath":"27","messages":"28","errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"29","messages":"30","errorCount":0,"fatalErrorCount":0,"warningCount":32,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31"},{"filePath":"32","messages":"33","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"34","messages":"35","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"36","messages":"37","errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38"},{"filePath":"39","messages":"40","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41"},{"filePath":"42","messages":"43","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"44","messages":"45","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46"},"D:\\cn\\phim\\frontend\\src\\index.js",[],"D:\\cn\\phim\\frontend\\src\\App.js",["47"],"import React, { useState, useEffect } from 'react';\r\nimport './App.css';\r\nimport AuthPage from './pages/AuthPage';\r\nimport HomePage from './pages/HomePage';\r\nimport RecommendationsPage from './pages/RecommendationsPage';\r\nimport ProfilePage from './pages/ProfilePage';\r\nimport CollectionsPage from './pages/CollectionsPage';\r\n\r\nexport default function App() {\r\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\r\n  const [currentPage, setCurrentPage] = useState('home');\r\n  const [pageHistory, setPageHistory] = useState(['home']);\r\n  const [user, setUser] = useState(null);\r\n  const [selectedMovie, setSelectedMovie] = useState(null);\r\n\r\n  // Prefetch data for faster page transitions\r\n  const prefetchCollections = () => {\r\n    const cacheKey = 'collection_best_2024';\r\n    if (!localStorage.getItem(cacheKey)) {\r\n      fetch(`${process.env.REACT_APP_API_BASE || 'http://localhost:8000'}/collections/best_2024?limit=30`)\r\n        .then(r => r.ok ? r.json() : null)\r\n        .then(data => {\r\n          if (data) {\r\n            try {\r\n              localStorage.setItem(cacheKey, JSON.stringify(data));\r\n            } catch (e) {}\r\n          }\r\n        })\r\n        .catch(() => {});\r\n    }\r\n  };\r\n\r\n  const prefetchRecommendations = () => {\r\n    const userId = user?.userId || 'Anonymous';\r\n    const cacheKey = `cached_recs_hybrid_${userId}`;\r\n    if (!localStorage.getItem(cacheKey)) {\r\n      fetch(`${process.env.REACT_APP_API_BASE || 'http://localhost:8000'}/recommendations?rec_type=hybrid&n=20&user_id=${userId}`)\r\n        .then(r => r.ok ? r.json() : null)\r\n        .then(data => {\r\n          if (data) {\r\n            try {\r\n              localStorage.setItem(cacheKey, JSON.stringify(data));\r\n            } catch (e) {}\r\n          }\r\n        })\r\n        .catch(() => {});\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    // Check if user is logged in\r\n    const storedUser = localStorage.getItem('user');\r\n    if (storedUser) {\r\n      const u = JSON.parse(storedUser);\r\n      // ensure userId exists\r\n      if (!u.userId) {\r\n        u.userId = `user_${Date.now()}_${Math.random().toString(36).slice(2,9)}`;\r\n        localStorage.setItem('user', JSON.stringify(u));\r\n        // best-effort notify backend\r\n        try { fetch(`${process.env.REACT_APP_API_BASE || 'http://localhost:8000'}/users`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ userId: u.userId, metadata: JSON.stringify({ name: u.name, email: u.email }) }) }).catch(()=>{}); } catch(e){}\r\n      }\r\n      setUser(u);\r\n      setIsAuthenticated(true);\r\n      \r\n      // Prefetch key data immediately for faster navigation\r\n      setTimeout(() => {\r\n        prefetchCollections();\r\n        prefetchRecommendations();\r\n      }, 500);\r\n    }\r\n  }, []);\r\n\r\n  const handleLogin = () => {\r\n    const storedUser = localStorage.getItem('user');\r\n    if (storedUser) {\r\n      setUser(JSON.parse(storedUser));\r\n      setIsAuthenticated(true);\r\n    }\r\n  };\r\n\r\n  const handleLogout = () => {\r\n    localStorage.removeItem('user');\r\n    setUser(null);\r\n    setIsAuthenticated(false);\r\n    setCurrentPage('home');\r\n    setPageHistory(['home']);\r\n  };\r\n\r\n  const navigateTo = (page) => {\r\n    setPageHistory([...pageHistory, page]);\r\n    setCurrentPage(page);\r\n  };\r\n\r\n  const handleMovieClick = (movie) => {\r\n    setSelectedMovie(movie);\r\n    navigateTo('watch');\r\n  };\r\n\r\n  const goBack = () => {\r\n    if (pageHistory.length > 1) {\r\n      const newHistory = [...pageHistory];\r\n      newHistory.pop(); // Remove current page\r\n      const previousPage = newHistory[newHistory.length - 1];\r\n      setPageHistory(newHistory);\r\n      setCurrentPage(previousPage);\r\n      if (previousPage !== 'watch') {\r\n        setSelectedMovie(null);\r\n      }\r\n    }\r\n  };\r\n\r\n  if (!isAuthenticated) {\r\n    return <AuthPage onLogin={handleLogin} />;\r\n  }\r\n\r\n  return (\r\n    <div className=\"app-container\">\r\n      <aside className=\"sidebar\">\r\n        <div className=\"sidebar-header\">\r\n          <h1 className=\"brand-text\">FilmFlow</h1>\r\n        </div>\r\n        <nav className=\"sidebar-nav\">\r\n          <button \r\n            className={`nav-link ${currentPage === 'home' ? 'active' : ''}`}\r\n            onClick={() => navigateTo('home')}\r\n          >\r\n            <span className=\"nav-text\">Trang ch·ªß</span>\r\n          </button>\r\n          <button \r\n            className={`nav-link ${currentPage === 'collections' ? 'active' : ''}`}\r\n            onClick={() => navigateTo('collections')}\r\n            onMouseEnter={prefetchCollections}\r\n          >\r\n            <span className=\"nav-text\">B·ªô S∆∞u T·∫≠p</span>\r\n          </button>\r\n          <button \r\n            className={`nav-link ${currentPage === 'profile' ? 'active' : ''}`}\r\n            onClick={() => navigateTo('profile')}\r\n          >\r\n            <span className=\"nav-text\">H·ªì S∆°</span>\r\n          </button>\r\n          <div className=\"sidebar-footer\">\r\n            <div className=\"user-info\">\r\n              <span className=\"user-name\">{user?.name || user?.email}</span>\r\n            </div>\r\n            <button className=\"nav-link logout-btn\" onClick={handleLogout}>\r\n              <span className=\"nav-text\">ƒêƒÉng xu·∫•t</span>\r\n            </button>\r\n          </div>\r\n        </nav>\r\n      </aside>\r\n\r\n      <main className=\"main-content\">\r\n        {currentPage === 'home' && <HomePage onMovieClick={handleMovieClick} />}\r\n        {currentPage === 'recommendations' && <RecommendationsPage onBack={goBack} />}\r\n        {currentPage === 'collections' && <CollectionsPage onMovieClick={handleMovieClick} />}\r\n        {currentPage === 'profile' && <ProfilePage />}\r\n        {currentPage === 'watch' && <RecommendationsPage onBack={goBack} initialMovie={selectedMovie} />}\r\n      </main>\r\n    </div>\r\n  );\r\n}\r\n","D:\\cn\\phim\\frontend\\src\\pages\\HomePage.js",["48","49","50","51","52","53","54","55","56","57","58","59","60","61","62"],"D:\\cn\\phim\\frontend\\src\\pages\\RecommendationsPage.js",["63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94"],"import React, { useState, useEffect } from 'react';\r\nimport styles from './RecommendationsPage.module.css';\r\nimport { API_BASE } from '../config';\r\nimport { MovieCardSkeleton } from '../components/MovieSkeleton';\r\n\r\nexport default function RecommendationsPage({ onBack, initialMovie }) {\r\n    const [recType] = useState('hybrid');\r\n    const [recommendations, setRecommendations] = useState([]);\r\n    const [loading, setLoading] = useState(true);\r\n    const [error, setError] = useState('');\r\n    const [movieHistory, setMovieHistory] = useState([]); // Stack of viewed movies\r\n    const [similarMoviesCache, setSimilarMoviesCache] = useState({}); // Cache similar movies by movie ID\r\n    const [likes, setLikes] = useState({}); // Track liked movies\r\n    const [dislikes, setDislikes] = useState({}); // Track disliked movies\r\n    const [watchlist, setWatchlist] = useState({}); // Track watchlist movies\r\n    const [reviewRating, setReviewRating] = useState(0); // Review rating (1-5)\r\n    const [comments, setComments] = useState([]);\r\n    const [commentText, setCommentText] = useState('');\r\n    const [showAllComments, setShowAllComments] = useState(false);\r\n    const [hoverRating, setHoverRating] = useState(0); // Hover rating for preview\r\n    const [videoProgress, setVideoProgress] = useState({}); // Track video progress {movieId: {timestamp, duration}}\r\n    const [player, setPlayer] = useState(null); // YouTube player instance\r\n    const playerRef = React.useRef(null);\r\n    \r\n    const currentMovie = movieHistory.length > 0 ? movieHistory[movieHistory.length - 1] : null;\r\n    const similarMovies = currentMovie ? (similarMoviesCache[currentMovie.id] || []) : [];\r\n\r\n    // Load saved video progress from localStorage\r\n    useEffect(() => {\r\n        try {\r\n            const saved = localStorage.getItem('video_progress');\r\n            if (saved) {\r\n                setVideoProgress(JSON.parse(saved));\r\n            }\r\n        } catch (e) {\r\n            console.warn('Failed to load video progress:', e);\r\n        }\r\n    }, []);\r\n\r\n    // Load watchlist from localStorage on mount\r\n    useEffect(() => {\r\n        try {\r\n            const stored = localStorage.getItem('user');\r\n            const user = stored ? JSON.parse(stored) : null;\r\n            if (user?.userId) {\r\n                const cacheKey = `watchlist_${user.userId}`;\r\n                const cached = localStorage.getItem(cacheKey);\r\n                if (cached) {\r\n                    const watchlistData = JSON.parse(cached);\r\n                    const watchlistMap = {};\r\n                    watchlistData.forEach(movie => {\r\n                        watchlistMap[movie.id] = true;\r\n                    });\r\n                    setWatchlist(watchlistMap);\r\n                }\r\n                \r\n                // Load likes/dislikes from cache on mount\r\n                const likesCacheKey = `likes_cache_${user.userId}`;\r\n                const likesCache = localStorage.getItem(likesCacheKey);\r\n                if (likesCache) {\r\n                    const likesMap = JSON.parse(likesCache);\r\n                    const newLikes = {};\r\n                    const newDislikes = {};\r\n                    Object.keys(likesMap).forEach(movieId => {\r\n                        const action = likesMap[movieId];\r\n                        if (action === 'like') {\r\n                            newLikes[movieId] = true;\r\n                            newDislikes[movieId] = false;\r\n                        } else if (action === 'dislike') {\r\n                            newDislikes[movieId] = true;\r\n                            newLikes[movieId] = false;\r\n                        }\r\n                    });\r\n                    setLikes(newLikes);\r\n                    setDislikes(newDislikes);\r\n                }\r\n            }\r\n        } catch (e) {\r\n            console.warn('Failed to load user state:', e);\r\n        }\r\n    }, []);\r\n\r\n    // Load initial movie if provided (from HomePage click)\r\n    useEffect(() => {\r\n        if (initialMovie) {\r\n            // If history is empty or last movie differs, open the initial movie\r\n            const last = movieHistory.length > 0 ? movieHistory[movieHistory.length - 1] : null;\r\n            if (!last || last.id !== initialMovie.id) {\r\n                openMovie(initialMovie);\r\n            }\r\n        }\r\n    }, [initialMovie]);\r\n\r\n    const getYouTubeEmbedUrl = (url) => {\r\n        if (!url) return null;\r\n        \r\n        // N·∫øu l√† embed URL, tr·∫£ v·ªÅ tr·ª±c ti·∫øp\r\n        if (url.includes('/embed')) {\r\n            // N·∫øu backend tr·∫£ v·ªÅ URL embed, chuy·ªÉn hostname sang youtube-nocookie ƒë·ªÉ gi·∫£m kh·∫£ nƒÉng b·ªã block\r\n            try {\r\n                const u = new URL(url);\r\n                u.hostname = u.hostname.replace('www.youtube.com', 'www.youtube-nocookie.com').replace('youtube.com', 'www.youtube-nocookie.com');\r\n                return u.toString();\r\n            } catch (e) {\r\n                return url;\r\n            }\r\n        }\r\n        \r\n        // N·∫øu l√† watch URL, extract video ID\r\n        try {\r\n            const urlObj = new URL(url);\r\n            if (urlObj.hostname.includes('youtube.com') || urlObj.hostname.includes('www.youtube.com')) {\r\n                const videoId = urlObj.searchParams.get('v');\r\n                if (videoId) return `https://www.youtube-nocookie.com/embed/${videoId}`;\r\n            }\r\n            if (urlObj.hostname.includes('youtu.be')) {\r\n                const videoId = urlObj.pathname.slice(1).split('?')[0];\r\n                if (videoId) return `https://www.youtube-nocookie.com/embed/${videoId}`;\r\n            }\r\n        } catch (e) {\r\n            console.error('Error parsing YouTube URL:', e);\r\n            return null;\r\n        }\r\n        return null;\r\n    };\r\n\r\n    const isSearchEmbed = (url) => {\r\n        if (!url) return false;\r\n        try {\r\n            const u = new URL(url);\r\n            const params = u.searchParams;\r\n            if (params.get('listType') === 'search') return true;\r\n            // if it's an embed without a video id and contains 'list=' it's likely a search/embed playlist\r\n            if (u.pathname && u.pathname.includes('/embed') && params.get('list')) return true;\r\n            return false;\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n    };\r\n\r\n    // Save video progress to localStorage and backend\r\n    const saveVideoProgress = async (movieId, timestamp, duration) => {\r\n        if (!movieId || timestamp === null || timestamp === undefined) return;\r\n        \r\n        // Save to state and localStorage\r\n        const newProgress = {\r\n            ...videoProgress,\r\n            [movieId]: { timestamp: Math.floor(timestamp), duration: Math.floor(duration || 0), savedAt: Date.now() }\r\n        };\r\n        setVideoProgress(newProgress);\r\n        \r\n        try {\r\n            localStorage.setItem('video_progress', JSON.stringify(newProgress));\r\n        } catch (e) {\r\n            console.warn('Failed to save progress to localStorage:', e);\r\n        }\r\n        \r\n        // Save to backend watch history\r\n        try {\r\n            const stored = localStorage.getItem('user');\r\n            const user = stored ? JSON.parse(stored) : null;\r\n            const userId = user?.userId || 'Anonymous';\r\n            \r\n            await fetch(`${API_BASE}/watch-history`, {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json' },\r\n                body: JSON.stringify({\r\n                    user_id: userId,\r\n                    movie_id: movieId,\r\n                    timestamp: Math.floor(timestamp),\r\n                    duration: Math.floor(duration || 0)\r\n                })\r\n            });\r\n        } catch (e) {\r\n            console.warn('Failed to save progress to backend:', e);\r\n        }\r\n    };\r\n\r\n    const openMovie = async (movie) => {\r\n        console.debug('openMovie called for', movie && movie.id, movie && movie.title);\r\n\r\n        // Create a unique id for this history entry so we can update it later\r\n        const historyId = `${Date.now()}-${Math.floor(Math.random() * 100000)}`;\r\n\r\n        // Push a placeholder entry into history immediately so UI shows right away\r\n        const placeholder = {\r\n            ...movie,\r\n            video_url: movie.video_url || null,\r\n            poster_url: movie.poster_url || null,\r\n            loadingTrailer: !movie.video_url,\r\n            historyId,\r\n        };\r\n\r\n        setMovieHistory(prev => ([...prev, placeholder]));\r\n\r\n        // Record a view interaction for personalization (best-effort)\r\n        try {\r\n            const stored = localStorage.getItem('user');\r\n            const user = stored ? JSON.parse(stored) : null;\r\n            if (user && user.userId) {\r\n                fetch(`${API_BASE}/interactions`, {\r\n                    method: 'POST',\r\n                    headers: { 'Content-Type': 'application/json' },\r\n                    body: JSON.stringify({ userId: user.userId, movieId: movie.id, action: 'view' })\r\n                }).catch(()=>{});\r\n            }\r\n        } catch (e) {}\r\n\r\n        // Fetch user's last interaction for this movie to restore like/dislike state\r\n        try {\r\n            const stored = localStorage.getItem('user');\r\n            const user = stored ? JSON.parse(stored) : null;\r\n            if (user && user.userId) {\r\n                // Check watchlist status from localStorage\r\n                try {\r\n                    const cacheKey = `watchlist_${user.userId}`;\r\n                    const cached = localStorage.getItem(cacheKey);\r\n                    if (cached) {\r\n                        const watchlistData = JSON.parse(cached);\r\n                        const isInWatchlist = watchlistData.some(m => m.id === movie.id);\r\n                        setWatchlist(prev => ({ ...prev, [movie.id]: isInWatchlist }));\r\n                    }\r\n                } catch (e) {\r\n                    console.warn('Failed to check watchlist status:', e);\r\n                }\r\n\r\n                // Check local cache first\r\n                try {\r\n                    const cacheKey = `likes_cache_${user.userId}`;\r\n                    const raw = localStorage.getItem(cacheKey);\r\n                    if (raw) {\r\n                        const map = JSON.parse(raw);\r\n                        if (map && map[movie.id]) {\r\n                            const action = map[movie.id];\r\n                            if (action === 'like') {\r\n                                setLikes(prev => ({ ...prev, [movie.id]: true }));\r\n                                setDislikes(prev => ({ ...prev, [movie.id]: false }));\r\n                            } else if (action === 'dislike') {\r\n                                setDislikes(prev => ({ ...prev, [movie.id]: true }));\r\n                                setLikes(prev => ({ ...prev, [movie.id]: false }));\r\n                            }\r\n                            // skip remote fetch when cached\r\n                            return;\r\n                        }\r\n                    }\r\n                } catch (e) {\r\n                    // ignore cache failures\r\n                }\r\n\r\n                // remote fetch with limit=1 for speed\r\n                fetch(`${API_BASE}/interactions?user_id=${encodeURIComponent(user.userId)}&movie_id=${movie.id}&limit=1`)\r\n                    .then(res => res.ok ? res.json() : null)\r\n                    .then(data => {\r\n                        if (data && data.results && data.results.length > 0) {\r\n                            const last = data.results[0];\r\n                            if (last.action === 'like') {\r\n                                setLikes(prev => ({ ...prev, [movie.id]: true }));\r\n                                setDislikes(prev => ({ ...prev, [movie.id]: false }));\r\n                                // update cache\r\n                                try {\r\n                                    const cacheKey = `likes_cache_${user.userId}`;\r\n                                    const raw = localStorage.getItem(cacheKey);\r\n                                    const map = raw ? JSON.parse(raw) : {};\r\n                                    map[movie.id] = 'like';\r\n                                    localStorage.setItem(cacheKey, JSON.stringify(map));\r\n                                } catch (e) {}\r\n                            } else if (last.action === 'dislike') {\r\n                                setDislikes(prev => ({ ...prev, [movie.id]: true }));\r\n                                setLikes(prev => ({ ...prev, [movie.id]: false }));\r\n                                try {\r\n                                    const cacheKey = `likes_cache_${user.userId}`;\r\n                                    const raw = localStorage.getItem(cacheKey);\r\n                                    const map = raw ? JSON.parse(raw) : {};\r\n                                    map[movie.id] = 'dislike';\r\n                                    localStorage.setItem(cacheKey, JSON.stringify(map));\r\n                                } catch (e) {}\r\n                            }\r\n                        }\r\n                    }).catch(()=>{});\r\n            }\r\n        } catch (e) {}\r\n\r\n        // Fetch and update trailer/poster asynchronously if we don't already have a video\r\n        if (!movie.video_url) {\r\n            try {\r\n                const resp = await fetch(`${API_BASE}/movies/${movie.id}/trailer`);\r\n                console.debug('trailer endpoint response status', resp.status);\r\n                if (resp.ok) {\r\n                    const data = await resp.json();\r\n                    console.debug('trailer endpoint data', data);\r\n                    // Update the history entry by historyId\r\n                    setMovieHistory(prev => prev.map(entry => {\r\n                        if (entry.historyId === historyId) {\r\n                            return {\r\n                                ...entry,\r\n                                video_url: data?.video_url || entry.video_url,\r\n                                poster_url: data?.poster_url || entry.poster_url,\r\n                                loadingTrailer: false,\r\n                            };\r\n                        }\r\n                        return entry;\r\n                    }));\r\n                } else {\r\n                    // still mark as not loading and provide fallback\r\n                    setMovieHistory(prev => prev.map(entry => entry.historyId === historyId ? ({...entry, loadingTrailer: false}) : entry));\r\n                }\r\n            } catch (err) {\r\n                console.error('Failed to fetch trailer endpoint:', err);\r\n                setMovieHistory(prev => prev.map(entry => entry.historyId === historyId ? ({...entry, loadingTrailer: false}) : entry));\r\n            }\r\n\r\n            // If after the fetch there's still no video_url, set a YouTube search URL fallback (but don't embed it)\r\n            setMovieHistory(prev => prev.map(entry => {\r\n                if (entry.historyId !== historyId) return entry;\r\n                if (entry.video_url) return entry;\r\n                try {\r\n                    const title = entry.title || '';\r\n                    const year = entry.year ? ` ${entry.year}` : '';\r\n                    const query = encodeURIComponent(`${title}${year} trailer`);\r\n                    return {\r\n                        ...entry,\r\n                        // store a search URL (we will open it in new tab rather than embedding)\r\n                        video_url: `https://www.youtube.com/results?search_query=${query}`\r\n                    };\r\n                } catch (e) {\r\n                    return entry;\r\n                }\r\n            }));\r\n        }\r\n\r\n        // Fetch similar movies in background (non-blocking)\r\n        if (!similarMoviesCache[movie.id]) {\r\n            fetch(`${API_BASE}/recommendations?rec_type=content&movie_id=${movie.id}&n=10`)\r\n                .then(response => response.ok ? response.json() : null)\r\n                .then(data => {\r\n                    if (data && data.results) {\r\n                        setSimilarMoviesCache(prev => ({\r\n                            ...prev,\r\n                            [movie.id]: data.results\r\n                        }));\r\n                    }\r\n                })\r\n                .catch(err => console.error('Failed to fetch similar movies:', err));\r\n        }\r\n\r\n        // Fetch latest comments for this movie (background)\r\n        try {\r\n            fetch(`${API_BASE}/movies/${movie.id}/comments?limit=20`)\r\n                .then(res => res.ok ? res.json() : null)\r\n                .then(data => {\r\n                    if (data && data.comments) {\r\n                        setComments(data.comments);\r\n                        setShowAllComments(false);\r\n                    }\r\n                }).catch(()=>{});\r\n        } catch (e) {}\r\n    };\r\n\r\n    const handleLike = async () => {\r\n        if (!currentMovie) return;\r\n        try {\r\n            // Persist interaction to server with userId\r\n            const stored = localStorage.getItem('user');\r\n            const user = stored ? JSON.parse(stored) : null;\r\n            if (user && user.userId) {\r\n                await fetch(`${API_BASE}/interactions`, {\r\n                    method: 'POST',\r\n                    headers: { 'Content-Type': 'application/json' },\r\n                    body: JSON.stringify({ userId: user.userId, movieId: currentMovie.id, action: 'like' })\r\n                });\r\n            } else {\r\n                await fetch(`${API_BASE}/movies/${currentMovie.id}/like`, { method: 'POST' });\r\n            }\r\n            const movieId = currentMovie.id;\r\n            const isCurrentlyLiked = likes[movieId];\r\n            \r\n            setLikes(prev => ({ ...prev, [movieId]: !isCurrentlyLiked }));\r\n            // If clicking like, remove dislike\r\n            if (!isCurrentlyLiked) {\r\n                setDislikes(prev => ({ ...prev, [movieId]: false }));\r\n                \r\n                // Save to cache\r\n                if (user && user.userId) {\r\n                    try {\r\n                        const cacheKey = `likes_cache_${user.userId}`;\r\n                        const raw = localStorage.getItem(cacheKey);\r\n                        const map = raw ? JSON.parse(raw) : {};\r\n                        map[movieId] = 'like';\r\n                        localStorage.setItem(cacheKey, JSON.stringify(map));\r\n                    } catch (e) {\r\n                        console.warn('Failed to save like cache:', e);\r\n                    }\r\n                }\r\n            } else {\r\n                // Remove from cache if toggling off\r\n                if (user && user.userId) {\r\n                    try {\r\n                        const cacheKey = `likes_cache_${user.userId}`;\r\n                        const raw = localStorage.getItem(cacheKey);\r\n                        const map = raw ? JSON.parse(raw) : {};\r\n                        delete map[movieId];\r\n                        localStorage.setItem(cacheKey, JSON.stringify(map));\r\n                    } catch (e) {\r\n                        console.warn('Failed to update like cache:', e);\r\n                    }\r\n                }\r\n            }\r\n        } catch (err) {\r\n            console.error('Failed to like movie:', err);\r\n        }\r\n    };\r\n\r\n    const handleDislike = async () => {\r\n        if (!currentMovie) return;\r\n        try {\r\n            const stored = localStorage.getItem('user');\r\n            const user = stored ? JSON.parse(stored) : null;\r\n            if (user && user.userId) {\r\n                await fetch(`${API_BASE}/interactions`, {\r\n                    method: 'POST',\r\n                    headers: { 'Content-Type': 'application/json' },\r\n                    body: JSON.stringify({ userId: user.userId, movieId: currentMovie.id, action: 'dislike' })\r\n                });\r\n            } else {\r\n                await fetch(`${API_BASE}/movies/${currentMovie.id}/dislike`, { method: 'POST' });\r\n            }\r\n            const movieId = currentMovie.id;\r\n            const isCurrentlyDisliked = dislikes[movieId];\r\n            \r\n            setDislikes(prev => ({ ...prev, [movieId]: !isCurrentlyDisliked }));\r\n            // If clicking dislike, remove like\r\n            if (!isCurrentlyDisliked) {\r\n                setLikes(prev => ({ ...prev, [movieId]: false }));\r\n                \r\n                // Save to cache\r\n                if (user && user.userId) {\r\n                    try {\r\n                        const cacheKey = `likes_cache_${user.userId}`;\r\n                        const raw = localStorage.getItem(cacheKey);\r\n                        const map = raw ? JSON.parse(raw) : {};\r\n                        map[movieId] = 'dislike';\r\n                        localStorage.setItem(cacheKey, JSON.stringify(map));\r\n                    } catch (e) {\r\n                        console.warn('Failed to save dislike cache:', e);\r\n                    }\r\n                }\r\n            } else {\r\n                // Remove from cache if toggling off\r\n                if (user && user.userId) {\r\n                    try {\r\n                        const cacheKey = `likes_cache_${user.userId}`;\r\n                        const raw = localStorage.getItem(cacheKey);\r\n                        const map = raw ? JSON.parse(raw) : {};\r\n                        delete map[movieId];\r\n                        localStorage.setItem(cacheKey, JSON.stringify(map));\r\n                    } catch (e) {\r\n                        console.warn('Failed to update dislike cache:', e);\r\n                    }\r\n                }\r\n            }\r\n        } catch (err) {\r\n            console.error('Failed to dislike movie:', err);\r\n        }\r\n    };\r\n\r\n    const handleWatchlist = async () => {\r\n        if (!currentMovie) return;\r\n        try {\r\n            const stored = localStorage.getItem('user');\r\n            const user = stored ? JSON.parse(stored) : null;\r\n            const userId = user?.userId || 'Anonymous';\r\n            \r\n            const isInWatchlist = watchlist[currentMovie.id];\r\n            \r\n            // Use new PostgreSQL API endpoint\r\n            const response = await fetch(`${API_BASE}/user/${userId}/watchlist/toggle?movie_id=${currentMovie.id}`, {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json' }\r\n            });\r\n            \r\n            if (response.ok) {\r\n                const result = await response.json();\r\n                const nowInWatchlist = result.in_watchlist;\r\n                \r\n                setWatchlist(prev => ({ ...prev, [currentMovie.id]: nowInWatchlist }));\r\n                \r\n                // Update localStorage cache\r\n                try {\r\n                    const cacheKey = `watchlist_${userId}`;\r\n                    const cached = localStorage.getItem(cacheKey);\r\n                    let watchlistData = cached ? JSON.parse(cached) : [];\r\n                    \r\n                    if (result.action === 'removed') {\r\n                        watchlistData = watchlistData.filter(m => m.id !== currentMovie.id);\r\n                    } else {\r\n                        // Add movie if not already in list\r\n                        const exists = watchlistData.some(m => m.id === currentMovie.id);\r\n                        if (!exists) {\r\n                            watchlistData.push(currentMovie);\r\n                        }\r\n                    }\r\n                    \r\n                    localStorage.setItem(cacheKey, JSON.stringify(watchlistData));\r\n                } catch (e) {\r\n                    console.warn('Failed to update watchlist cache:', e);\r\n                }\r\n            }\r\n        } catch (err) {\r\n            console.error('Failed to update watchlist:', err);\r\n        }\r\n    };\r\n\r\n    // Quick submit rating (1-5 sao) without opening modal\r\n    const handleRate = async (star) => {\r\n        if (!currentMovie) return;\r\n        try {\r\n            const stored = localStorage.getItem('user');\r\n            const user = stored ? JSON.parse(stored) : null;\r\n            const payload = {\r\n                rating: star,\r\n                review_text: '',\r\n                username: user && user.userId ? user.userId : 'Anonymous'\r\n            };\r\n            const response = await fetch(`${API_BASE}/movies/${currentMovie.id}/review`, {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json' },\r\n                body: JSON.stringify(payload)\r\n            });\r\n            if (response.ok) {\r\n                setReviewRating(star);\r\n                alert('C·∫£m ∆°n b·∫°n ƒë√£ ƒë√°nh gi√°!');\r\n            } else {\r\n                alert('G·ª≠i ƒë√°nh gi√° th·∫•t b·∫°i');\r\n            }\r\n        } catch (err) {\r\n            console.error('Failed to submit rating:', err);\r\n            alert('L·ªói khi g·ª≠i ƒë√°nh gi√°. Vui l√≤ng th·ª≠ l·∫°i!');\r\n        }\r\n    };\r\n\r\n    const handleSubmitComment = async () => {\r\n        if (!currentMovie) return;\r\n        try {\r\n            const stored = localStorage.getItem('user');\r\n            const user = stored ? JSON.parse(stored) : null;\r\n            const payload = {\r\n                userId: user && user.userId ? user.userId : 'Anonymous',\r\n                comment: commentText || ''\r\n            };\r\n            // If we have a registered display name locally, ensure server has the user metadata\r\n            if (user && user.userId && (user.name || user.email)) {\r\n                try {\r\n                    await fetch(`${API_BASE}/users`, {\r\n                        method: 'POST',\r\n                        headers: { 'Content-Type': 'application/json' },\r\n                        body: JSON.stringify({ userId: user.userId, metadata: JSON.stringify({ name: user.name, email: user.email }) })\r\n                    });\r\n                } catch (e) {\r\n                    // best-effort - ignore errors\r\n                }\r\n            }\r\n            if (!payload.comment.trim()) {\r\n                alert('Vui l√≤ng nh·∫≠p b√¨nh lu·∫≠n');\r\n                return;\r\n            }\r\n            const resp = await fetch(`${API_BASE}/movies/${currentMovie.id}/comment`, {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json' },\r\n                body: JSON.stringify(payload)\r\n            });\r\n            if (resp.ok) {\r\n                const data = await resp.json();\r\n                // prepend local comment to list and include display_name for immediate UI\r\n                const displayName = (user && (user.name || user.displayName)) || payload.userId;\r\n                setComments(prev => ([{ id: Date.now(), movieId: currentMovie.id, userId: payload.userId, display_name: displayName, comment: payload.comment, timestamp: new Date().toISOString() }, ...prev]));\r\n                setCommentText('');\r\n            } else {\r\n                alert('G·ª≠i b√¨nh lu·∫≠n th·∫•t b·∫°i');\r\n            }\r\n        } catch (e) {\r\n            console.error('Failed to submit comment', e);\r\n            alert('L·ªói khi g·ª≠i b√¨nh lu·∫≠n');\r\n        }\r\n    };\r\n\r\n    const goBack = () => {\r\n        if (movieHistory.length > 1) {\r\n            // Remove current movie from history\r\n            const newHistory = [...movieHistory];\r\n            newHistory.pop();\r\n            setMovieHistory(newHistory);\r\n        } else if (movieHistory.length === 1) {\r\n            // Return to recommendations list\r\n            setMovieHistory([]);\r\n        }\r\n    };\r\n\r\n    // Movie card component\r\n    const MovieCard = ({ movie, isCompact }) => {\r\n        return (\r\n            <div className={isCompact ? styles.movieCardCompact : styles.movieCard} onClick={() => openMovie(movie)}>\r\n                <div className={styles.moviePosterContainer}>\r\n                    {movie.poster_url ? (\r\n                        <img src={movie.poster_url} alt={movie.title} className={styles.moviePoster} loading=\"lazy\" />\r\n                    ) : (\r\n                        <div className={styles.moviePosterPlaceholder}><p>Kh√¥ng c√≥ Poster</p></div>\r\n                    )}\r\n                    <div className={styles.playOverlay}>‚ñ∂</div>\r\n                </div>\r\n                <div className={styles.movieDetails}>\r\n                    <h3 className={styles.movieTitle}>{movie.title} {movie.year > 0 && `(${movie.year})`}</h3>\r\n                    <p className={styles.rating}>‚≠ê {movie.vote_average || 'N/A'}/10</p>\r\n                    {!isCompact && <p className={styles.overview}>{movie.overview?.substring(0, 100)}...</p>}\r\n                </div>\r\n            </div>\r\n        );\r\n    };\r\n\r\n    const handleGetRecommendations = async () => {\r\n        setLoading(true);\r\n        setError('');\r\n        setRecommendations([]);\r\n\r\n        try {\r\n            // Fast-path: load from cache first to render immediately\r\n            const stored = localStorage.getItem('user');\r\n            const user = stored ? JSON.parse(stored) : null;\r\n            const cacheKey = `cached_recs_${recType}_${user && user.userId ? user.userId : 'public'}`;\r\n            try {\r\n                const raw = localStorage.getItem(cacheKey);\r\n                if (raw) {\r\n                    const parsed = JSON.parse(raw);\r\n                    const movies = parsed.results || [];\r\n                    if (movies.length > 0) {\r\n                        setRecommendations(movies);\r\n                        setLoading(false);\r\n                    }\r\n                }\r\n            } catch (e) {}\r\n\r\n            const userParam = user && user.userId ? `&user_id=${encodeURIComponent(user.userId)}` : '';\r\n            const url = `${API_BASE}/recommendations?rec_type=${encodeURIComponent(recType)}&n=10${userParam}`;\r\n            const response = await fetch(url);\r\n            if (!response.ok) {\r\n                const errorText = await response.text();\r\n                throw new Error(`L·ªói l·∫•y g·ª£i √Ω: ${response.status} - ${errorText.substring(0, 200)}`);\r\n            }\r\n            const data = await response.json();\r\n            const results = data.results || [];\r\n            // update UI and cache\r\n            setRecommendations(results);\r\n            try {\r\n                localStorage.setItem(cacheKey, JSON.stringify({ ts: Date.now(), results }));\r\n            } catch (e) {}\r\n            if (results.length === 0) setError('Kh√¥ng t√¨m th·∫•y g·ª£i √Ω n√†o.');\r\n        } catch (err) {\r\n            setError(`Th·∫•t b·∫°i khi k·∫øt n·ªëi: ${err.message}`);\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    };\r\n\r\n    useEffect(() => { handleGetRecommendations(); }, []);\r\n\r\n    // Load YouTube IFrame API\r\n    useEffect(() => {\r\n        if (!window.YT) {\r\n            const tag = document.createElement('script');\r\n            tag.src = 'https://www.youtube.com/iframe_api';\r\n            const firstScriptTag = document.getElementsByTagName('script')[0];\r\n            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\r\n        }\r\n    }, []);\r\n\r\n    // Auto-save progress every 10 seconds when playing\r\n    useEffect(() => {\r\n        if (!currentMovie || !player) return;\r\n        \r\n        const interval = setInterval(() => {\r\n            try {\r\n                if (player && typeof player.getCurrentTime === 'function' && typeof player.getDuration === 'function') {\r\n                    const currentTime = player.getCurrentTime();\r\n                    const duration = player.getDuration();\r\n                    if (currentTime > 0 && duration > 0) {\r\n                        saveVideoProgress(currentMovie.id, currentTime, duration);\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                // Player might not be ready\r\n            }\r\n        }, 10000); // Save every 10 seconds\r\n        \r\n        return () => clearInterval(interval);\r\n    }, [currentMovie, player]);\r\n\r\n    // Save progress when user leaves page\r\n    useEffect(() => {\r\n        const handleBeforeUnload = () => {\r\n            if (currentMovie && player) {\r\n                try {\r\n                    const currentTime = player.getCurrentTime();\r\n                    const duration = player.getDuration();\r\n                    if (currentTime > 0) {\r\n                        saveVideoProgress(currentMovie.id, currentTime, duration);\r\n                    }\r\n                } catch (e) {}\r\n            }\r\n        };\r\n        \r\n        window.addEventListener('beforeunload', handleBeforeUnload);\r\n        return () => window.removeEventListener('beforeunload', handleBeforeUnload);\r\n    }, [currentMovie, player]);\r\n\r\n    return (\r\n        <div className={styles.mainContent}>\r\n            {!currentMovie ? (\r\n                <>\r\n                    <header className={styles.header}>\r\n                        <h1 className={styles.pageHeader}>‚≠ê ƒê·ªÅ Xu·∫•t Phim Cho B·∫°n</h1>\r\n                    </header>\r\n\r\n                    {error && <div className={styles.error}>{error}</div>}\r\n                    {loading && recommendations.length === 0 && (\r\n                        <div className={styles.recommendationsContainer}>\r\n                            <div className={styles.skeletonTitle}></div>\r\n                            <div className={styles.movieRow}>\r\n                                {Array.from({length: 6}).map((_, i) => (\r\n                                    <div key={i} className={styles.movieCardSkeleton}>\r\n                                        <div className={styles.skeletonPoster}></div>\r\n                                        <div className={styles.skeletonText}></div>\r\n                                        <div className={styles.skeletonText} style={{width: '60%'}}></div>\r\n                                    </div>\r\n                                ))}\r\n                            </div>\r\n                        </div>\r\n                    )}\r\n\r\n                    {recommendations.length > 0 && (\r\n                        <div className={styles.recommendationsContainer}>\r\n                            <h2 className={styles.rowTitle}>üé¨ ƒê·ªÅ xu·∫•t h√†ng ƒë·∫ßu ({recommendations.length})</h2>\r\n                            <div className={styles.movieRow}>\r\n                                {recommendations.map((movie, idx) => (<MovieCard key={idx} movie={movie} />))}\r\n                            </div>\r\n                        </div>\r\n                    )}\r\n                </>\r\n            ) : (\r\n                <div className={styles.moviePlayerContainer}>\r\n                    <button className={styles.backButton} onClick={goBack}>\r\n                        ‚Üê Quay l·∫°i\r\n                    </button>\r\n                    \r\n                    <div className={styles.playerSection}>\r\n                        <div className={styles.videoPlayer}>\r\n                            {(() => {\r\n                                const embed = currentMovie.video_url ? (getYouTubeEmbedUrl(currentMovie.video_url) || currentMovie.video_url) : null;\r\n                                const searchEmbed = embed ? isSearchEmbed(embed) : false;\r\n                                // If we have a proper embed and it's not a search-type embed, show iframe\r\n                                if (embed && !searchEmbed && embed.includes('/embed')) {\r\n                                    const sep = embed.includes('?') ? '&' : '?';\r\n                                    const savedProgress = videoProgress[currentMovie.id];\r\n                                    const startTime = savedProgress?.timestamp > 5 ? savedProgress.timestamp : 0;\r\n                                    const startParam = startTime > 0 ? `&start=${startTime}` : '';\r\n                                    \r\n                                    return (\r\n                                        <iframe\r\n                                            id={`youtube-player-${currentMovie.id}`}\r\n                                            width=\"100%\"\r\n                                            height=\"100%\"\r\n                                            title={currentMovie.title}\r\n                                            frameBorder=\"0\"\r\n                                            allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\r\n                                            allowFullScreen\r\n                                            referrerPolicy=\"strict-origin-when-cross-origin\"\r\n                                            src={`${embed}${sep}autoplay=1&mute=0&rel=0&modestbranding=1&enablejsapi=1${startParam}`}\r\n                                            onLoad={() => {\r\n                                                // Wait for YouTube IFrame API to be ready before initializing\r\n                                                const initPlayer = () => {\r\n                                                    if (window.YT && window.YT.Player) {\r\n                                                        try {\r\n                                                            const ytPlayer = new window.YT.Player(`youtube-player-${currentMovie.id}`, {\r\n                                                                events: {\r\n                                                                    'onReady': (event) => {\r\n                                                                        console.log('YouTube player ready');\r\n                                                                        setPlayer(event.target);\r\n                                                                        playerRef.current = event.target;\r\n                                                                        // Seek to saved position if available\r\n                                                                        if (startTime > 5) {\r\n                                                                            setTimeout(() => {\r\n                                                                                try {\r\n                                                                                    event.target.seekTo(startTime, true);\r\n                                                                                } catch (e) {\r\n                                                                                    console.warn('Failed to seek:', e);\r\n                                                                                }\r\n                                                                            }, 1000);\r\n                                                                        }\r\n                                                                        \r\n                                                                        // Auto-save progress every 10 seconds\r\n                                                                        const saveInterval = setInterval(() => {\r\n                                                                            try {\r\n                                                                                const player = playerRef.current;\r\n                                                                                if (player && typeof player.getCurrentTime === 'function') {\r\n                                                                                    const currentTime = player.getCurrentTime();\r\n                                                                                    const duration = player.getDuration();\r\n                                                                                    if (currentTime > 0) {\r\n                                                                                        saveVideoProgress(currentMovie.id, currentTime, duration);\r\n                                                                                    }\r\n                                                                                }\r\n                                                                            } catch (e) {}\r\n                                                                        }, 10000);\r\n                                                                        \r\n                                                                        // Clear interval when player is destroyed\r\n                                                                        return () => clearInterval(saveInterval);\r\n                                                                    },\r\n                                                                    'onStateChange': (event) => {\r\n                                                                        // Save when paused\r\n                                                                        if (event.data === window.YT.PlayerState.PAUSED) {\r\n                                                                            try {\r\n                                                                                const currentTime = event.target.getCurrentTime();\r\n                                                                                const duration = event.target.getDuration();\r\n                                                                                saveVideoProgress(currentMovie.id, currentTime, duration);\r\n                                                                            } catch (e) {}\r\n                                                                        }\r\n                                                                    }\r\n                                                                }\r\n                                                            });\r\n                                                        } catch (e) {\r\n                                                            console.warn('Failed to initialize YouTube player:', e);\r\n                                                        }\r\n                                                    } else {\r\n                                                        // YT API not ready yet, try again in 500ms\r\n                                                        setTimeout(initPlayer, 500);\r\n                                                    }\r\n                                                };\r\n                                                \r\n                                                // Start initialization with slight delay to ensure iframe is ready\r\n                                                setTimeout(initPlayer, 200);\r\n                                            }}\r\n                                        />\r\n                                    );\r\n                                }\r\n\r\n                                // Otherwise show poster with message + button to open YouTube search\r\n                                if (currentMovie.poster_url) {\r\n                                    return (\r\n                                        <div className={styles.noPoster}>\r\n                                            <img src={currentMovie.poster_url} alt={currentMovie.title} style={{width: '100%', height: '100%', objectFit: 'contain'}} />\r\n                                            <div className={styles.noVideoOverlay}>\r\n                                                {currentMovie.loadingTrailer ? 'ƒêang t·∫£i phim...' : 'Trailer kh√¥ng kh·∫£ d·ª•ng'}\r\n                                            </div>\r\n                                            <div style={{position: 'absolute', right: 12, bottom: 12}}>\r\n                                                <button className={styles.openYouTubeBtn} onClick={() => window.open(currentMovie.video_url || `https://www.youtube.com/results?search_query=${encodeURIComponent(currentMovie.title || '')}`, '_blank')}>\r\n                                                    M·ªü trailer tr√™n YouTube\r\n                                                </button>\r\n                                            </div>\r\n                                        </div>\r\n                                    );\r\n                                }\r\n\r\n                                return (\r\n                                    <div className={styles.noVideo}>\r\n                                        {currentMovie.loadingTrailer ? 'ƒêang t·∫£i phim...' : 'Kh√¥ng c√≥ trailer'}\r\n                                    </div>\r\n                                );\r\n                            })()}\r\n                        </div>\r\n                        \r\n                        <div className={styles.movieInfo}>\r\n                            <h1 className={styles.movieInfoTitle}>{currentMovie.title} {currentMovie.year > 0 && `(${currentMovie.year})`}</h1>\r\n                            <div className={styles.movieMeta}>\r\n                                <span className={styles.movieRating}>‚≠ê {currentMovie.vote_average || 'N/A'}/10</span>\r\n                                <span className={styles.movieVotes}>({currentMovie.vote_count || 0} votes)</span>\r\n                            </div>\r\n                            <p className={styles.movieDescription}>{currentMovie.overview}</p>\r\n\r\n                            {/* Like/Dislike/Watchlist/Review Buttons */}\r\n                            <div className={styles.interactionButtons}>\r\n                                <button \r\n                                    className={`${styles.likeBtn} ${likes[currentMovie.id] ? styles.active : ''}`}\r\n                                    onClick={handleLike}\r\n                                    title=\"Th√≠ch phim n√†y\"\r\n                                >\r\n                                    üëç Th√≠ch\r\n                                </button>\r\n                                <button \r\n                                    className={`${styles.dislikeBtn} ${dislikes[currentMovie.id] ? styles.active : ''}`}\r\n                                    onClick={handleDislike}\r\n                                    title=\"Kh√¥ng th√≠ch\"\r\n                                >\r\n                                    üëé Kh√¥ng th√≠ch\r\n                                </button>\r\n                                <button \r\n                                    className={`${styles.watchlistBtn} ${watchlist[currentMovie.id] ? styles.active : ''}`}\r\n                                    onClick={handleWatchlist}\r\n                                    title={watchlist[currentMovie.id] ? \"X√≥a kh·ªèi danh s√°ch\" : \"L∆∞u v√†o danh s√°ch\"}\r\n                                >\r\n                                    {watchlist[currentMovie.id] ? '‚úì ƒê√£ l∆∞u' : '+ L∆∞u'}\r\n                                </button>\r\n                                <div className={styles.ratingInline}>\r\n                                    {[1,2,3,4,5].map(star => (\r\n                                        <button\r\n                                            key={star}\r\n                                            className={`${styles.star} ${(hoverRating || reviewRating) >= star ? styles.starActive : ''}`}\r\n                                            onClick={() => handleRate(star)}\r\n                                            onMouseEnter={() => setHoverRating(star)}\r\n                                            onMouseLeave={() => setHoverRating(0)}\r\n                                            title={`ƒê√°nh gi√° ${star} sao`}\r\n                                        >\r\n                                            ‚≠ê\r\n                                        </button>\r\n                                    ))}\r\n                                </div>\r\n                            </div>\r\n                            {/* Comments section */}\r\n                            <div className={styles.commentsSection}>\r\n                                <h3>B√¨nh lu·∫≠n</h3>\r\n                                <div className={styles.commentForm}>\r\n                                    <textarea value={commentText} onChange={(e) => setCommentText(e.target.value)} placeholder=\"Vi·∫øt b√¨nh lu·∫≠n...\" rows={3} />\r\n                                    <button className={styles.submitBtn} onClick={handleSubmitComment}>G·ª≠i</button>\r\n                                </div>\r\n                                <div className={styles.commentList}>\r\n                                    {comments.length === 0 && <div>Ch∆∞a c√≥ b√¨nh lu·∫≠n n√†o.</div>}\r\n                                    {comments.length > 0 && (\r\n                                        (showAllComments ? comments : comments.slice(0, 2)).map(c => (\r\n                                            <div key={c.id} className={styles.commentItem}>\r\n                                                <div className={styles.commentMeta}><strong>{c.display_name || c.userId}</strong> ‚Ä¢ <span className={styles.commentTime}>{new Date(c.timestamp).toLocaleString()}</span></div>\r\n                                                <div className={styles.commentText}>{c.comment}</div>\r\n                                            </div>\r\n                                        ))\r\n                                    )}\r\n\r\n                                    {comments.length > 2 && (\r\n                                        <div className={styles.commentToggle}>\r\n                                            <button className={styles.smallBtn} onClick={() => setShowAllComments(prev => !prev)}>\r\n                                                {showAllComments ? `R√∫t g·ªçn` : `Xem th√™m ${comments.length - 2} b√¨nh lu·∫≠n`}\r\n                                            </button>\r\n                                        </div>\r\n                                    )}\r\n                                </div>\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n\r\n                    {/* Review modal removed: replaced by quick star rating */}\r\n\r\n                    <div className={styles.similarMoviesSection}>\r\n                        <h2 className={styles.sectionTitle}>G·ª£i √Ω cho b·∫°n</h2>\r\n                        {similarMovies.length > 0 ? (\r\n                            <div className={styles.similarMoviesGrid}>\r\n                                {similarMovies.map((movie, idx) => (\r\n                                    <MovieCard key={idx} movie={movie} isCompact={true} />\r\n                                ))}\r\n                            </div>\r\n                        ) : (\r\n                            <div className={styles.loadingMovies}>ƒêang t·∫£i...</div>\r\n                        )}\r\n                    </div>\r\n                    <div style={{marginTop: 12}}>\r\n                        <button className={styles.openYouTubeBtn} onClick={() => {\r\n                            const title = currentMovie?.title || '';\r\n                            const year = currentMovie?.year ? ` ${currentMovie.year}` : '';\r\n                            const query = encodeURIComponent(`${title}${year} trailer`);\r\n                            window.open(`https://www.youtube.com/results?search_query=${query}`, '_blank');\r\n                        }}>\r\n                            M·ªü trailer tr√™n YouTube\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n}","D:\\cn\\phim\\frontend\\src\\config.js",[],"D:\\cn\\phim\\frontend\\src\\pages\\AuthPage.js",[],"D:\\cn\\phim\\frontend\\src\\pages\\ProfilePage.js",["95","96","97","98","99","100","101","102","103","104"],"import React, { useState, useEffect } from 'react';\r\nimport './ProfilePage.css';\r\nimport { API_BASE } from '../config';\r\n\r\nexport default function ProfilePage() {\r\n  const [user, setUser] = useState(null);\r\n  const [profile, setProfile] = useState(null);\r\n  const [preferences, setPreferences] = useState({});\r\n  const [watchlist, setWatchlist] = useState([]);\r\n  const [watchHistory, setWatchHistory] = useState([]);\r\n  const [movieData, setMovieData] = useState({}); // Store full movie data by ID\r\n  const [loading, setLoading] = useState(true);\r\n  const [initialLoad, setInitialLoad] = useState(true);\r\n  const [selectedQuality, setSelectedQuality] = useState('720p');\r\n  const [selectedLangs, setSelectedLangs] = useState(['vi', 'en']);\r\n  const [showAllHistory, setShowAllHistory] = useState(false);\r\n  const [showAllWatchlist, setShowAllWatchlist] = useState(false);\r\n\r\n  useEffect(() => {\r\n    const storedUser = localStorage.getItem('user');\r\n    if (storedUser) {\r\n      const userData = JSON.parse(storedUser);\r\n      setUser(userData);\r\n      // Always skip cache on mount to get fresh data\r\n      fetchProfile(userData.userId, true);\r\n    } else {\r\n      setLoading(false);\r\n    }\r\n  }, []);\r\n\r\n  const fetchProfile = async (userId, skipCache = false) => {\r\n    // Try cache first for instant display (unless skipCache is true)\r\n    if (!skipCache) {\r\n      try {\r\n        const cacheKey = `profile_${userId}`;\r\n        const cached = localStorage.getItem(cacheKey);\r\n        if (cached) {\r\n          const data = JSON.parse(cached);\r\n          setProfile(data.profile);\r\n          setPreferences(data.preferences || {});\r\n          setWatchlist(data.watchlist || []);\r\n          setWatchHistory(data.history || []);\r\n          setLoading(false);\r\n          setInitialLoad(false);\r\n        }\r\n      } catch (e) {}\r\n    }\r\n    \r\n    try {\r\n      // Fetch user stats from new PostgreSQL API\r\n      const statsResponse = await fetch(`${API_BASE}/user/${userId}/stats`);\r\n      if (statsResponse.ok) {\r\n        const stats = await statsResponse.json();\r\n        setProfile({\r\n          userId: userId,\r\n          name: stats.name || user?.name,\r\n          email: stats.email || user?.email,\r\n          totalRatings: stats.total_ratings || 0,\r\n          totalWatchlist: stats.total_watchlist || 0,\r\n          totalWatched: stats.total_watched || 0,\r\n          totalReviews: stats.total_reviews || 0,\r\n          favoriteGenres: stats.favorite_genres || [],\r\n          createdAt: stats.created_at\r\n        });\r\n      }\r\n      \r\n      // Get preferences (keep old logic)\r\n      try {\r\n        const prefsRes = await fetch(`${API_BASE}/user/${userId}/preferences`);\r\n        if (prefsRes.ok) {\r\n          const prefs = await prefsRes.json();\r\n          setPreferences(prefs.preferences || {});\r\n        }\r\n      } catch (e) {\r\n        console.warn('Failed to fetch preferences:', e);\r\n      }\r\n      \r\n      // Get watchlist from new PostgreSQL API\r\n      try {\r\n        const watchlistRes = await fetch(`${API_BASE}/user/${userId}/watchlist`);\r\n        if (watchlistRes.ok) {\r\n          const watchlistData = await watchlistRes.json();\r\n          const movies = watchlistData.movies || [];\r\n          \r\n          // Deduplicate by movie ID\r\n          const uniqueMovies = [];\r\n          const seenIds = new Set();\r\n          movies.forEach(movie => {\r\n            const movieId = movie.id || movie.movie_id;\r\n            if (!seenIds.has(movieId)) {\r\n              seenIds.add(movieId);\r\n              uniqueMovies.push({\r\n                ...movie,\r\n                id: movieId,\r\n                poster_url: movie.poster_url || movie.poster_path\r\n              });\r\n            }\r\n          });\r\n          \r\n          setWatchlist(uniqueMovies);\r\n          \r\n          // Build movie data map\r\n          const movieMap = {};\r\n          uniqueMovies.forEach(movie => {\r\n            movieMap[movie.id] = movie;\r\n          });\r\n          setMovieData(prev => ({...prev, ...movieMap}));\r\n        }\r\n      } catch (e) {\r\n        console.warn('Failed to fetch watchlist:', e);\r\n      }\r\n      \r\n      // Get watch history from new PostgreSQL API\r\n      try {\r\n        const historyRes = await fetch(`${API_BASE}/user/${userId}/watched`);\r\n        if (historyRes.ok) {\r\n          const historyData = await historyRes.json();\r\n          const movies = historyData.movies || [];\r\n          \r\n          // Deduplicate by movieId - keep only most recent entry for each movie\r\n          const uniqueHistory = [];\r\n          const seenMovieIds = new Set();\r\n          movies.forEach(movie => {\r\n            const movieId = movie.id || movie.movie_id;\r\n            if (!seenMovieIds.has(movieId)) {\r\n              seenMovieIds.add(movieId);\r\n              uniqueHistory.push({\r\n                movieId: movieId,\r\n                watchedAt: movie.watched_at,\r\n                progress: movie.progress,\r\n                completed: movie.completed,\r\n                ...movie\r\n              });\r\n            }\r\n          });\r\n          \r\n          setWatchHistory(uniqueHistory);\r\n          \r\n          // Build movie data map\r\n          const movieMap = {};\r\n          uniqueHistory.forEach(entry => {\r\n            movieMap[entry.movieId] = {\r\n              id: entry.movieId,\r\n              title: entry.title,\r\n              poster_url: entry.poster_url || entry.poster_path,\r\n              year: entry.year,\r\n              vote_average: entry.vote_average\r\n            };\r\n          });\r\n          setMovieData(prev => ({...prev, ...movieMap}));\r\n        }\r\n      } catch (e) {\r\n        console.warn('Failed to fetch watch history:', e);\r\n      }\r\n      \r\n      // Cache everything for next time\r\n      try {\r\n        const cacheKey = `profile_${userId}`;\r\n        localStorage.setItem(cacheKey, JSON.stringify({\r\n          profile: profile,\r\n          preferences: preferences,\r\n          watchlist: watchlist,\r\n          history: watchHistory\r\n        }));\r\n      } catch (e) {}\r\n      \r\n      setLoading(false);\r\n      setInitialLoad(false);\r\n    } catch (error) {\r\n      console.error('Failed to fetch profile:', error);\r\n      setLoading(false);\r\n      setInitialLoad(false);\r\n    }\r\n  };\r\n\r\n  const updateQuality = async (quality) => {\r\n    setSelectedQuality(quality);\r\n    localStorage.setItem('video_quality', quality);\r\n  };\r\n\r\n  const updateLanguages = async (langs) => {\r\n    setSelectedLangs(langs);\r\n    localStorage.setItem('subtitle_languages', JSON.stringify(langs));\r\n  };\r\n\r\n  const updateGenrePreferences = async (genres) => {\r\n    try {\r\n      const response = await fetch(`${API_BASE}/user/${user.userId}/preferences`, {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({\r\n          favorite_genres: genres,\r\n          quality: selectedQuality,\r\n          languages: selectedLangs\r\n        })\r\n      });\r\n      if (response.ok) {\r\n        setPreferences({ ...preferences, favorite_genres: genres });\r\n        // Refresh profile data\r\n        fetchProfile(user.userId);\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to update preferences:', error);\r\n    }\r\n  };\r\n  \r\n  const removeFromWatchlist = async (movieId) => {\r\n    try {\r\n      // Use new PostgreSQL API endpoint\r\n      const response = await fetch(`${API_BASE}/user/${user.userId}/watchlist/toggle?movie_id=${movieId}`, {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' }\r\n      });\r\n      \r\n      if (response.ok) {\r\n        const result = await response.json();\r\n        if (result.action === 'removed') {\r\n          const updatedWatchlist = watchlist.filter(m => m.id !== movieId);\r\n          setWatchlist(updatedWatchlist);\r\n          \r\n          // Update localStorage cache\r\n          try {\r\n            const cacheKey = `watchlist_${user.userId}`;\r\n            localStorage.setItem(cacheKey, JSON.stringify(updatedWatchlist));\r\n          } catch (e) {\r\n            console.warn('Failed to update watchlist cache:', e);\r\n          }\r\n        }\r\n      } else {\r\n        console.error('Failed to remove from watchlist:', await response.text());\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to remove from watchlist:', error);\r\n    }\r\n  };\r\n\r\n  if (initialLoad) {\r\n    return (\r\n      <div className=\"profile-page\">\r\n        <div className=\"profile-container\">\r\n          {/* Skeleton Header */}\r\n          <div className=\"profile-header\">\r\n            <div className=\"profile-avatar skeleton-avatar\">üë§</div>\r\n            <div className=\"profile-info\">\r\n              <div className=\"skeleton-text skeleton-title\"></div>\r\n              <div className=\"skeleton-text skeleton-subtitle\"></div>\r\n            </div>\r\n          </div>\r\n          \r\n          {/* Skeleton sections */}\r\n          <div className=\"settings-section\">\r\n            <div className=\"skeleton-text skeleton-heading\"></div>\r\n            <div className=\"skeleton-box\"></div>\r\n          </div>\r\n          \r\n          <div className=\"watchlist-section\">\r\n            <div className=\"skeleton-text skeleton-heading\"></div>\r\n            <div className=\"movies-grid\">\r\n              {Array.from({length: 6}).map((_, i) => (\r\n                <div key={i} className=\"movie-card-skeleton\"></div>\r\n              ))}\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n  \r\n  if (!user) return <div className=\"profile-page\"><p>Please login first</p></div>;\r\n\r\n  return (\r\n    <div className=\"profile-page\">\r\n      <div className=\"profile-container\">\r\n        \r\n        {/* Header */}\r\n        <div className=\"profile-header\">\r\n          <div className=\"profile-avatar\">üë§</div>\r\n          <div className=\"profile-info\">\r\n            <h1>{user.userId}</h1>\r\n          </div>\r\n        </div>\r\n\r\n        {/* Settings */}\r\n        <div className=\"settings-section\">\r\n          <h2>‚öôÔ∏è C√†i ƒê·∫∑t</h2>\r\n          \r\n          {/* Video Quality */}\r\n          <div className=\"setting-group\">\r\n            <h3>Ch·∫•t L∆∞·ª£ng Video</h3>\r\n            <div className=\"quality-options\">\r\n              {['480p', '720p', '1080p', '4K'].map(quality => (\r\n                <button\r\n                  key={quality}\r\n                  className={`quality-btn ${selectedQuality === quality ? 'active' : ''}`}\r\n                  onClick={() => updateQuality(quality)}\r\n                >\r\n                  {quality}\r\n                </button>\r\n              ))}\r\n            </div>\r\n          </div>\r\n\r\n          {/* Languages */}\r\n          <div className=\"setting-group\">\r\n            <h3>Ng√¥n Ng·ªØ Ph·ª• ƒê·ªÅ</h3>\r\n            <div className=\"language-options\">\r\n              {[\r\n                { code: 'vi', name: 'Ti·∫øng Vi·ªát' },\r\n                { code: 'en', name: 'English' },\r\n                { code: 'zh', name: '‰∏≠Êñá' }\r\n              ].map(lang => (\r\n                <label key={lang.code} className=\"language-checkbox\">\r\n                  <input\r\n                    type=\"checkbox\"\r\n                    checked={selectedLangs.includes(lang.code)}\r\n                    onChange={(e) => {\r\n                      if (e.target.checked) {\r\n                        updateLanguages([...selectedLangs, lang.code]);\r\n                      } else {\r\n                        updateLanguages(selectedLangs.filter(l => l !== lang.code));\r\n                      }\r\n                    }}\r\n                  />\r\n                  {lang.name}\r\n                </label>\r\n              ))}\r\n            </div>\r\n          </div>\r\n\r\n          {/* Favorite Genres */}\r\n          <div className=\"setting-group\">\r\n            <h3>Th·ªÉ Lo·∫°i Y√™u Th√≠ch</h3>\r\n            <div className=\"genre-options\">\r\n              {['Action', 'Comedy', 'Drama', 'Horror', 'Romance', 'Sci-Fi'].map(genre => (\r\n                <button\r\n                  key={genre}\r\n                  className={`genre-btn ${preferences.favorite_genres?.includes(genre) ? 'active' : ''}`}\r\n                  onClick={() => {\r\n                    const current = preferences.favorite_genres || [];\r\n                    if (current.includes(genre)) {\r\n                      updateGenrePreferences(current.filter(g => g !== genre));\r\n                    } else {\r\n                      updateGenrePreferences([...current, genre]);\r\n                    }\r\n                  }}\r\n                >\r\n                  {genre}\r\n                </button>\r\n              ))}\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        {/* Stats Section */}\r\n        <div className=\"stats-section\">\r\n          <h2>üìä Th·ªëng K√™</h2>\r\n          <div className=\"stats-grid\">\r\n            <div className=\"stat-card\">\r\n              <div className=\"stat-value\">{profile?.totalRatings || 0}</div>\r\n              <div className=\"stat-label\">ƒê√°nh Gi√°</div>\r\n            </div>\r\n            <div className=\"stat-card\">\r\n              <div className=\"stat-value\">{profile?.totalWatchlist || 0}</div>\r\n              <div className=\"stat-label\">Phim ƒê√£ L∆∞u</div>\r\n            </div>\r\n            <div className=\"stat-card\">\r\n              <div className=\"stat-value\">{profile?.favoriteGenres?.length || 0}</div>\r\n              <div className=\"stat-label\">Th·ªÉ Lo·∫°i Y√™u Th√≠ch</div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        {/* Watch History */}\r\n        {watchHistory?.length > 0 && (\r\n          <div className=\"activity-section\">\r\n            <h2>üì∫ L·ªãch S·ª≠ Xem ({watchHistory.length})</h2>\r\n            <div className=\"movies-grid\">\r\n              {watchHistory.slice(0, showAllHistory ? watchHistory.length : 5).map((entry) => {\r\n                const movie = movieData[entry.movieId];\r\n                if (!movie) return null;\r\n                return (\r\n                  <div key={entry.movieId} className=\"movie-poster-card\">\r\n                    <div className=\"movie-poster-wrapper\">\r\n                      {movie.poster_url ? (\r\n                        <img src={movie.poster_url} alt={movie.title} className=\"movie-poster\" />\r\n                      ) : (\r\n                        <div className=\"no-poster\">Kh√¥ng c√≥ poster</div>\r\n                      )}\r\n                    </div>\r\n                    <div className=\"movie-poster-info\">\r\n                      <h4 className=\"movie-poster-title\">{movie.title}</h4>\r\n                      <p className=\"movie-poster-meta\">‚≠ê {movie.vote_average || 'N/A'}</p>\r\n                      <p className=\"movie-watch-date\">\r\n                        {new Date(entry.viewed_at || entry.timestamp).toLocaleDateString('vi-VN')}\r\n                      </p>\r\n                    </div>\r\n                  </div>\r\n                );\r\n              })}\r\n            </div>\r\n            {watchHistory.length > 5 && (\r\n              <div className=\"show-more-container\">\r\n                <button \r\n                  className=\"show-more-btn\"\r\n                  onClick={() => setShowAllHistory(!showAllHistory)}\r\n                >\r\n                  {showAllHistory ? '‚ñ≤ Thu g·ªçn' : `‚ñº Xem th√™m (${watchHistory.length - 5} phim)`}\r\n                </button>\r\n              </div>\r\n            )}\r\n          </div>\r\n        )}\r\n        \r\n        {/* Watchlist */}\r\n        {watchlist?.length > 0 && (\r\n          <div className=\"activity-section\">\r\n            <h2>‚ù§Ô∏è Danh S√°ch ƒê√£ L∆∞u ({watchlist.length})</h2>\r\n            <div className=\"movies-grid\">\r\n              {watchlist.slice(0, showAllWatchlist ? watchlist.length : 5).map((movie) => (\r\n                <div key={movie.id} className=\"movie-poster-card\">\r\n                  <div className=\"movie-poster-wrapper\">\r\n                    {movie.poster_url ? (\r\n                      <img src={movie.poster_url} alt={movie.title} className=\"movie-poster\" />\r\n                    ) : (\r\n                      <div className=\"no-poster\">Kh√¥ng c√≥ poster</div>\r\n                    )}\r\n                  </div>\r\n                  <div className=\"movie-poster-info\">\r\n                    <h4 className=\"movie-poster-title\">{movie.title}</h4>\r\n                    <p className=\"movie-poster-meta\">‚≠ê {movie.vote_average || 'N/A'}</p>\r\n                    <button \r\n                      className=\"remove-btn\"\r\n                      onClick={() => removeFromWatchlist(movie.id)}\r\n                    >\r\n                      üóëÔ∏è X√≥a\r\n                    </button>\r\n                  </div>\r\n                </div>\r\n              ))}\r\n            </div>\r\n            {watchlist.length > 5 && (\r\n              <div className=\"show-more-container\">\r\n                <button \r\n                  className=\"show-more-btn\"\r\n                  onClick={() => setShowAllWatchlist(!showAllWatchlist)}\r\n                >\r\n                  {showAllWatchlist ? '‚ñ≤ Thu g·ªçn' : `‚ñº Xem th√™m (${watchlist.length - 5} phim)`}\r\n                </button>\r\n              </div>\r\n            )}\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n","D:\\cn\\phim\\frontend\\src\\pages\\CollectionsPage.js",["105","106","107"],"import React, { useState, useEffect } from 'react';\r\nimport './CollectionsPage.css';\r\nimport { API_BASE } from '../config';\r\nimport { MovieCardSkeleton } from '../components/MovieSkeleton';\r\n\r\nfunction MovieCard({ movie, onClick }) {\r\n  const poster = movie.poster_url || movie.poster_path || movie.poster;\r\n  return (\r\n    <div className=\"collection-movie-card\" onClick={() => onClick && onClick(movie)}>\r\n      <div className=\"collection-movie-thumb\">\r\n        {poster ? (\r\n          <img \r\n            src={poster} \r\n            alt={movie.title} \r\n            loading=\"lazy\" \r\n            decoding=\"async\"\r\n            onError={(e) => {\r\n              e.target.onerror = null;\r\n              e.target.src = `https://picsum.photos/seed/${movie.id || movie.title}/300/450`;\r\n            }}\r\n          />\r\n        ) : (\r\n          <div className=\"no-poster\">Kh√¥ng c√≥ poster</div>\r\n        )}\r\n        <div className=\"collection-overlay\">\r\n          <button className=\"btn-play\">‚ñ∂ Xem ngay</button>\r\n        </div>\r\n      </div>\r\n      <h3>{movie.title}</h3>\r\n      <p className=\"movie-year\">{movie.year}</p>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default function CollectionsPage({ onMovieClick }) {\r\n  const [collections] = useState([\r\n    { id: 'horror', name: 'Horror Collection' },\r\n    { id: 'action', name: 'Action Movies' },\r\n    { id: 'top_rated', name: 'Top Rated' }\r\n  ]);\r\n\r\n  const [selectedCollection, setSelectedCollection] = useState('horror');\r\n  const [collectionMovies, setCollectionMovies] = useState([]);\r\n  const [collectionInfo, setCollectionInfo] = useState(null);\r\n  const [loading, setLoading] = useState(false);\r\n\r\n  useEffect(() => {\r\n    fetchCollection(selectedCollection);\r\n  }, [selectedCollection]);\r\n\r\n  const fetchCollection = async (collectionId) => {\r\n    setLoading(true);\r\n    // Try cache first for instant display\r\n    const cacheKey = `collection_${collectionId}`;\r\n    const cached = localStorage.getItem(cacheKey);\r\n    if (cached) {\r\n      try {\r\n        const data = JSON.parse(cached);\r\n        setCollectionInfo(data);\r\n        setCollectionMovies(data.movies || []);\r\n        setLoading(false);\r\n      } catch (e) {}\r\n    }\r\n    \r\n    try {\r\n      const response = await fetch(`${API_BASE}/collections/${collectionId}?limit=30`);\r\n      if (response.ok) {\r\n        const data = await response.json();\r\n        setCollectionInfo(data);\r\n        setCollectionMovies(data.movies || []);\r\n        // Cache for next time\r\n        try {\r\n          localStorage.setItem(cacheKey, JSON.stringify(data));\r\n        } catch (e) {}\r\n      } else {\r\n        console.error('Failed to fetch collection:', response.status);\r\n        if (!cached) {\r\n          setCollectionInfo(null);\r\n          setCollectionMovies([]);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to fetch collection:', error);\r\n      if (!cached) {\r\n        setCollectionInfo(null);\r\n        setCollectionMovies([]);\r\n      }\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"collections-page\">\r\n        {/* Header */}\r\n        <div className=\"collections-header\">\r\n          <h1>üé¨ B·ªô S∆∞u T·∫≠p Phim</h1>\r\n          <p>Kh√°m ph√° nh·ªØng b·ªô s∆∞u t·∫≠p phim ƒë∆∞·ª£c c·ªë g·∫Øng s·∫Øp x·∫øp</p>\r\n        </div>\r\n\r\n        {/* Collection Tabs */}\r\n        <div className=\"collections-tabs\">\r\n          {collections.map(col => (\r\n            <button\r\n              key={col.id}\r\n              className={`collection-tab ${selectedCollection === col.id ? 'active' : ''}`}\r\n              onClick={() => setSelectedCollection(col.id)}\r\n            >\r\n              {col.name}\r\n            </button>\r\n          ))}\r\n        </div>\r\n\r\n        {/* Collection Info */}\r\n        {collectionInfo && (\r\n          <div className=\"collection-info\">\r\n            <h2>{collectionInfo.title}</h2>\r\n            <p>{collectionInfo.description}</p>\r\n          </div>\r\n        )}\r\n\r\n        {/* Movies Grid */}\r\n        <div className=\"collections-grid\">\r\n          {loading && collectionMovies.length === 0 ? (\r\n            /* Show skeleton cards during initial load */\r\n            Array.from({ length: 12 }).map((_, i) => (\r\n              <div className=\"collection-movie-card skeleton\" key={`skeleton-${i}`}>\r\n                <div className=\"collection-movie-thumb\" />\r\n                <h3>&nbsp;</h3>\r\n                <p className=\"movie-year\">&nbsp;</p>\r\n              </div>\r\n            ))\r\n          ) : (\r\n            /* Show actual movies */\r\n            collectionMovies.map((movie, idx) => (\r\n              <MovieCard \r\n                key={movie.id || idx} \r\n                movie={movie} \r\n                onClick={onMovieClick}\r\n              />\r\n            ))\r\n          )}\r\n        </div>\r\n\r\n        {collectionMovies.length === 0 && !loading && (\r\n          <div className=\"no-movies\">\r\n            <p>Kh√¥ng c√≥ phim trong b·ªô s∆∞u t·∫≠p n√†y</p>\r\n          </div>\r\n        )}\r\n      </div>\r\n  );\r\n}\r\n","D:\\cn\\phim\\frontend\\src\\components\\MovieSkeleton.js",[],"D:\\cn\\phim\\frontend\\src\\components\\LazyImage.js",["108"],"import React, { useState, useEffect, useRef } from 'react';\r\n\r\n/**\r\n * LazyImage Component - Lazy load images with placeholder\r\n * Improves performance by loading images only when they're visible\r\n */\r\nconst LazyImage = ({ src, alt, className, style, placeholder }) => {\r\n  const [imageSrc, setImageSrc] = useState(placeholder || 'data:image/svg+xml,%3Csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 300 450\"%3E%3Crect fill=\"%23333\" width=\"300\" height=\"450\"/%3E%3C/svg%3E');\r\n  const [isLoaded, setIsLoaded] = useState(false);\r\n  const imgRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    // Use Intersection Observer for lazy loading\r\n    const observer = new IntersectionObserver(\r\n      entries => {\r\n        entries.forEach(entry => {\r\n          if (entry.isIntersecting) {\r\n            setImageSrc(src);\r\n            observer.unobserve(entry.target);\r\n          }\r\n        });\r\n      },\r\n      {\r\n        rootMargin: '50px', // Load images 50px before they become visible\r\n      }\r\n    );\r\n\r\n    if (imgRef.current) {\r\n      observer.observe(imgRef.current);\r\n    }\r\n\r\n    return () => {\r\n      if (imgRef.current) {\r\n        observer.unobserve(imgRef.current);\r\n      }\r\n    };\r\n  }, [src]);\r\n\r\n  return (\r\n    <img\r\n      ref={imgRef}\r\n      src={imageSrc}\r\n      alt={alt}\r\n      className={className}\r\n      style={{\r\n        ...style,\r\n        opacity: isLoaded ? 1 : 0.6,\r\n        transition: 'opacity 0.3s ease-in-out',\r\n      }}\r\n      onLoad={() => setIsLoaded(true)}\r\n      loading=\"lazy\"\r\n    />\r\n  );\r\n};\r\n\r\nexport default LazyImage;\r\n",{"ruleId":"109","severity":1,"message":"110","line":71,"column":6,"nodeType":"111","endLine":71,"endColumn":8,"suggestions":"112"},{"ruleId":"113","severity":1,"message":"114","line":4,"column":29,"nodeType":"115","messageId":"116","endLine":4,"endColumn":44},{"ruleId":"113","severity":1,"message":"117","line":68,"column":10,"nodeType":"115","messageId":"116","endLine":68,"endColumn":19},{"ruleId":"113","severity":1,"message":"118","line":69,"column":10,"nodeType":"115","messageId":"116","endLine":69,"endColumn":17},{"ruleId":"113","severity":1,"message":"119","line":69,"column":19,"nodeType":"115","messageId":"116","endLine":69,"endColumn":29},{"ruleId":"120","severity":1,"message":"121","line":132,"column":11,"nodeType":"122","messageId":"123","endLine":132,"endColumn":24},{"ruleId":"120","severity":1,"message":"121","line":157,"column":7,"nodeType":"122","messageId":"123","endLine":157,"endColumn":20},{"ruleId":"120","severity":1,"message":"121","line":214,"column":11,"nodeType":"122","messageId":"123","endLine":214,"endColumn":23},{"ruleId":"120","severity":1,"message":"121","line":318,"column":9,"nodeType":"122","messageId":"123","endLine":318,"endColumn":21},{"ruleId":"120","severity":1,"message":"121","line":344,"column":13,"nodeType":"122","messageId":"123","endLine":344,"endColumn":26},{"ruleId":"120","severity":1,"message":"121","line":389,"column":13,"nodeType":"122","messageId":"123","endLine":389,"endColumn":25},{"ruleId":"120","severity":1,"message":"121","line":393,"column":9,"nodeType":"122","messageId":"123","endLine":393,"endColumn":21},{"ruleId":"120","severity":1,"message":"121","line":436,"column":15,"nodeType":"122","messageId":"123","endLine":436,"endColumn":27},{"ruleId":"120","severity":1,"message":"121","line":440,"column":11,"nodeType":"122","messageId":"123","endLine":440,"endColumn":23},{"ruleId":"120","severity":1,"message":"121","line":464,"column":11,"nodeType":"122","messageId":"123","endLine":464,"endColumn":23},{"ruleId":"109","severity":1,"message":"124","line":470,"column":6,"nodeType":"111","endLine":470,"endColumn":8,"suggestions":"125"},{"ruleId":"113","severity":1,"message":"126","line":4,"column":10,"nodeType":"115","messageId":"116","endLine":4,"endColumn":27},{"ruleId":"120","severity":1,"message":"121","line":36,"column":13,"nodeType":"122","messageId":"123","endLine":36,"endColumn":25},{"ruleId":"120","severity":1,"message":"121","line":79,"column":13,"nodeType":"122","messageId":"123","endLine":79,"endColumn":25},{"ruleId":"109","severity":1,"message":"127","line":92,"column":8,"nodeType":"111","endLine":92,"endColumn":22,"suggestions":"128"},{"ruleId":"120","severity":1,"message":"121","line":121,"column":13,"nodeType":"122","messageId":"123","endLine":121,"endColumn":26},{"ruleId":"120","severity":1,"message":"121","line":155,"column":13,"nodeType":"122","messageId":"123","endLine":155,"endColumn":25},{"ruleId":"120","severity":1,"message":"121","line":175,"column":13,"nodeType":"122","messageId":"123","endLine":175,"endColumn":25},{"ruleId":"120","severity":1,"message":"121","line":180,"column":9,"nodeType":"122","messageId":"123","endLine":180,"endColumn":22},{"ruleId":"120","severity":1,"message":"121","line":224,"column":21,"nodeType":"122","messageId":"123","endLine":224,"endColumn":33},{"ruleId":"120","severity":1,"message":"121","line":287,"column":17,"nodeType":"122","messageId":"123","endLine":287,"endColumn":30},{"ruleId":"120","severity":1,"message":"121","line":290,"column":21,"nodeType":"122","messageId":"123","endLine":290,"endColumn":34},{"ruleId":"120","severity":1,"message":"121","line":308,"column":17,"nodeType":"122","messageId":"123","endLine":308,"endColumn":30},{"ruleId":"120","severity":1,"message":"121","line":343,"column":31,"nodeType":"122","messageId":"123","endLine":343,"endColumn":44},{"ruleId":"120","severity":1,"message":"121","line":391,"column":25,"nodeType":"122","messageId":"123","endLine":391,"endColumn":37},{"ruleId":"120","severity":1,"message":"121","line":404,"column":25,"nodeType":"122","messageId":"123","endLine":404,"endColumn":37},{"ruleId":"120","severity":1,"message":"121","line":409,"column":13,"nodeType":"122","messageId":"123","endLine":409,"endColumn":26},{"ruleId":"120","severity":1,"message":"121","line":444,"column":25,"nodeType":"122","messageId":"123","endLine":444,"endColumn":37},{"ruleId":"120","severity":1,"message":"121","line":457,"column":25,"nodeType":"122","messageId":"123","endLine":457,"endColumn":37},{"ruleId":"120","severity":1,"message":"121","line":462,"column":13,"nodeType":"122","messageId":"123","endLine":462,"endColumn":26},{"ruleId":"113","severity":1,"message":"129","line":473,"column":19,"nodeType":"115","messageId":"116","endLine":473,"endColumn":32},{"ruleId":"120","severity":1,"message":"121","line":505,"column":21,"nodeType":"122","messageId":"123","endLine":505,"endColumn":33},{"ruleId":"120","severity":1,"message":"121","line":509,"column":13,"nodeType":"122","messageId":"123","endLine":509,"endColumn":26},{"ruleId":"120","severity":1,"message":"121","line":536,"column":13,"nodeType":"122","messageId":"123","endLine":536,"endColumn":26},{"ruleId":"113","severity":1,"message":"130","line":572,"column":23,"nodeType":"115","messageId":"116","endLine":572,"endColumn":27},{"ruleId":"120","severity":1,"message":"121","line":581,"column":13,"nodeType":"122","messageId":"123","endLine":581,"endColumn":26},{"ruleId":"109","severity":1,"message":"131","line":663,"column":54,"nodeType":"111","endLine":663,"endColumn":56,"suggestions":"132"},{"ruleId":"109","severity":1,"message":"133","line":694,"column":8,"nodeType":"111","endLine":694,"endColumn":30,"suggestions":"134"},{"ruleId":"109","severity":1,"message":"133","line":712,"column":8,"nodeType":"111","endLine":712,"endColumn":30,"suggestions":"135"},{"ruleId":"113","severity":1,"message":"136","line":781,"column":67,"nodeType":"115","messageId":"116","endLine":781,"endColumn":75},{"ruleId":"120","severity":1,"message":"121","line":784,"column":73,"nodeType":"122","messageId":"123","endLine":784,"endColumn":84},{"ruleId":"120","severity":1,"message":"121","line":793,"column":85,"nodeType":"122","messageId":"123","endLine":793,"endColumn":97},{"ruleId":"120","severity":1,"message":"121","line":828,"column":61,"nodeType":"122","messageId":"123","endLine":828,"endColumn":73},{"ruleId":"113","severity":1,"message":"118","line":12,"column":10,"nodeType":"115","messageId":"116","endLine":12,"endColumn":17},{"ruleId":"109","severity":1,"message":"137","line":29,"column":6,"nodeType":"111","endLine":29,"endColumn":8,"suggestions":"138"},{"ruleId":"120","severity":1,"message":"121","line":75,"column":9,"nodeType":"122","messageId":"123","endLine":75,"endColumn":21},{"ruleId":"120","severity":1,"message":"121","line":110,"column":9,"nodeType":"122","messageId":"123","endLine":110,"endColumn":21},{"ruleId":"120","severity":1,"message":"121","line":153,"column":9,"nodeType":"122","messageId":"123","endLine":153,"endColumn":21},{"ruleId":"120","severity":1,"message":"121","line":170,"column":7,"nodeType":"122","messageId":"123","endLine":170,"endColumn":20},{"ruleId":"120","severity":1,"message":"121","line":203,"column":7,"nodeType":"122","messageId":"123","endLine":203,"endColumn":20},{"ruleId":"120","severity":1,"message":"121","line":226,"column":13,"nodeType":"122","messageId":"123","endLine":226,"endColumn":25},{"ruleId":"120","severity":1,"message":"121","line":230,"column":9,"nodeType":"122","messageId":"123","endLine":230,"endColumn":22},{"ruleId":"120","severity":1,"message":"121","line":233,"column":7,"nodeType":"122","messageId":"123","endLine":233,"endColumn":20},{"ruleId":"113","severity":1,"message":"126","line":4,"column":10,"nodeType":"115","messageId":"116","endLine":4,"endColumn":27},{"ruleId":"120","severity":1,"message":"121","line":76,"column":9,"nodeType":"122","messageId":"123","endLine":76,"endColumn":22},{"ruleId":"120","severity":1,"message":"121","line":83,"column":7,"nodeType":"122","messageId":"123","endLine":83,"endColumn":20},{"ruleId":"109","severity":1,"message":"139","line":34,"column":35,"nodeType":"115","endLine":34,"endColumn":42},"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'prefetchRecommendations'. Either include it or remove the dependency array.","ArrayExpression",["140"],"no-unused-vars","'SectionSkeleton' is defined but never used.","Identifier","unusedVar","'watchlist' is assigned a value but never used.","'loading' is assigned a value but never used.","'setLoading' is assigned a value but never used.","no-console","Unexpected console statement.","MemberExpression","unexpected","React Hook useEffect has a missing dependency: 'trendingMovies'. Either include it or remove the dependency array.",["141"],"'MovieCardSkeleton' is defined but never used.","React Hook useEffect has missing dependencies: 'movieHistory' and 'openMovie'. Either include them or remove the dependency array.",["142"],"'isInWatchlist' is assigned a value but never used.","'data' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'handleGetRecommendations'. Either include it or remove the dependency array.",["143"],"React Hook useEffect has a missing dependency: 'saveVideoProgress'. Either include it or remove the dependency array.",["144"],["145"],"'ytPlayer' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'fetchProfile'. Either include it or remove the dependency array.",["146"],"The ref value 'imgRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'imgRef.current' to a variable inside the effect, and use that variable in the cleanup function.",{"desc":"147","fix":"148"},{"desc":"149","fix":"150"},{"desc":"151","fix":"152"},{"desc":"153","fix":"154"},{"desc":"155","fix":"156"},{"desc":"155","fix":"157"},{"desc":"158","fix":"159"},"Update the dependencies array to be: [prefetchRecommendations]",{"range":"160","text":"161"},"Update the dependencies array to be: [trendingMovies]",{"range":"162","text":"163"},"Update the dependencies array to be: [initialMovie, movieHistory, openMovie]",{"range":"164","text":"165"},"Update the dependencies array to be: [handleGetRecommendations]",{"range":"166","text":"167"},"Update the dependencies array to be: [currentMovie, player, saveVideoProgress]",{"range":"168","text":"169"},{"range":"170","text":"169"},"Update the dependencies array to be: [fetchProfile]",{"range":"171","text":"172"},[2764,2766],"[prefetchRecommendations]",[17969,17971],"[trendingMovies]",[4331,4345],"[initialMovie, movieHistory, openMovie]",[30451,30453],"[handleGetRecommendations]",[31674,31696],"[currentMovie, player, saveVideoProgress]",[32388,32410],[1200,1202],"[fetchProfile]"]